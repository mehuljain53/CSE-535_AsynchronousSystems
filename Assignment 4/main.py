# -*- generated by 1.1.0b12 -*-
import da
PatternExpr_261 = da.pat.TuplePattern([da.pat.ConstantPattern('PreemtPropose'), da.pat.FreePattern('n2')])
PatternExpr_268 = da.pat.FreePattern('p')
PatternExpr_327 = da.pat.TuplePattern([da.pat.ConstantPattern('respond'), da.pat.BoundPattern('_BoundPattern330_'), da.pat.FreePattern(None)])
PatternExpr_334 = da.pat.FreePattern('a')
PatternExpr_369 = da.pat.TuplePattern([da.pat.ConstantPattern('respond'), da.pat.BoundPattern('_BoundPattern372_'), da.pat.TuplePattern([da.pat.FreePattern('n2'), da.pat.FreePattern('v')])])
PatternExpr_400 = da.pat.TuplePattern([da.pat.ConstantPattern('respond'), da.pat.BoundPattern('_BoundPattern403_'), da.pat.TuplePattern([da.pat.FreePattern('n2'), da.pat.FreePattern(None)])])
PatternExpr_436 = da.pat.TuplePattern([da.pat.ConstantPattern('respond'), da.pat.BoundPattern('_BoundPattern439_'), da.pat.FreePattern(None)])
PatternExpr_443 = da.pat.FreePattern('a')
PatternExpr_521 = da.pat.TuplePattern([da.pat.ConstantPattern('done')])
PatternExpr_575 = da.pat.TuplePattern([da.pat.ConstantPattern('prepare'), da.pat.FreePattern('n')])
PatternExpr_582 = da.pat.FreePattern('p')
PatternExpr_588 = da.pat.TuplePattern([da.pat.ConstantPattern('respond'), da.pat.FreePattern('n2'), da.pat.FreePattern(None)])
PatternExpr_617 = da.pat.TuplePattern([da.pat.ConstantPattern('accepted'), da.pat.FreePattern('n'), da.pat.FreePattern('v')])
PatternExpr_643 = da.pat.TuplePattern([da.pat.ConstantPattern('accepted'), da.pat.FreePattern('n'), da.pat.FreePattern(None)])
PatternExpr_685 = da.pat.TuplePattern([da.pat.ConstantPattern('respond'), da.pat.FreePattern('n2'), da.pat.FreePattern(None)])
PatternExpr_716 = da.pat.TuplePattern([da.pat.ConstantPattern('accept'), da.pat.FreePattern('n'), da.pat.FreePattern('v')])
PatternExpr_729 = da.pat.TuplePattern([da.pat.ConstantPattern('respond'), da.pat.FreePattern('n2'), da.pat.FreePattern(None)])
PatternExpr_766 = da.pat.TuplePattern([da.pat.ConstantPattern('done')])
PatternExpr_771 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern(None)]), da.pat.TuplePattern([da.pat.ConstantPattern('done')])])
PatternExpr_875 = da.pat.TuplePattern([da.pat.ConstantPattern('accepted'), da.pat.FreePattern('n'), da.pat.FreePattern('v')])
PatternExpr_901 = da.pat.TuplePattern([da.pat.ConstantPattern('accepted'), da.pat.BoundPattern('_BoundPattern904_'), da.pat.BoundPattern('_BoundPattern905_')])
PatternExpr_908 = da.pat.FreePattern('a')
PatternExpr_997 = da.pat.TuplePattern([da.pat.ConstantPattern('done')])
PatternExpr_1038 = da.pat.TuplePattern([da.pat.ConstantPattern('valueLearnt'), da.pat.FreePattern('n'), da.pat.FreePattern('v')])
PatternExpr_1047 = da.pat.FreePattern('p')
PatternExpr_1092 = da.pat.TuplePattern([da.pat.ConstantPattern('done')])
PatternExpr_1741 = da.pat.TuplePattern([da.pat.ConstantPattern('learned')])
PatternExpr_1746 = da.pat.BoundPattern('_BoundPattern1747_')
PatternExpr_1788 = da.pat.TuplePattern([da.pat.ConstantPattern('Notsafe'), da.pat.ConstantPattern(True)])
PatternExpr_1795 = da.pat.BoundPattern('_BoundPattern1796_')
PatternExpr_1820 = da.pat.TuplePattern([da.pat.ConstantPattern('safe'), da.pat.ConstantPattern(False)])
PatternExpr_1827 = da.pat.BoundPattern('_BoundPattern1828_')
PatternExpr_1850 = da.pat.TuplePattern([da.pat.ConstantPattern('safe'), da.pat.ConstantPattern(True)])
PatternExpr_1857 = da.pat.BoundPattern('_BoundPattern1858_')
PatternExpr_2095 = da.pat.TuplePattern([da.pat.ConstantPattern('learned')])
PatternExpr_2100 = da.pat.BoundPattern('_BoundPattern2101_')
PatternExpr_2141 = da.pat.TuplePattern([da.pat.ConstantPattern('Notsafe'), da.pat.ConstantPattern(True)])
PatternExpr_2148 = da.pat.BoundPattern('_BoundPattern2149_')
PatternExpr_2173 = da.pat.TuplePattern([da.pat.ConstantPattern('safe'), da.pat.ConstantPattern(False)])
PatternExpr_2180 = da.pat.BoundPattern('_BoundPattern2181_')
PatternExpr_2203 = da.pat.TuplePattern([da.pat.ConstantPattern('safe'), da.pat.ConstantPattern(True)])
PatternExpr_2210 = da.pat.BoundPattern('_BoundPattern2211_')
PatternExpr_2446 = da.pat.TuplePattern([da.pat.ConstantPattern('learned')])
PatternExpr_2451 = da.pat.BoundPattern('_BoundPattern2452_')
PatternExpr_2492 = da.pat.TuplePattern([da.pat.ConstantPattern('Notsafe'), da.pat.ConstantPattern(True)])
PatternExpr_2499 = da.pat.BoundPattern('_BoundPattern2500_')
PatternExpr_2524 = da.pat.TuplePattern([da.pat.ConstantPattern('safe'), da.pat.ConstantPattern(False)])
PatternExpr_2531 = da.pat.BoundPattern('_BoundPattern2532_')
PatternExpr_2554 = da.pat.TuplePattern([da.pat.ConstantPattern('safe'), da.pat.ConstantPattern(True)])
PatternExpr_2561 = da.pat.BoundPattern('_BoundPattern2562_')
PatternExpr_1748 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.BoundPattern('_BoundPattern1754_')]), da.pat.TuplePattern([da.pat.ConstantPattern('learned')])])
PatternExpr_1797 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.BoundPattern('_BoundPattern1803_')]), da.pat.TuplePattern([da.pat.ConstantPattern('Notsafe'), da.pat.ConstantPattern(True)])])
PatternExpr_1829 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.BoundPattern('_BoundPattern1835_')]), da.pat.TuplePattern([da.pat.ConstantPattern('safe'), da.pat.ConstantPattern(False)])])
PatternExpr_1859 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.BoundPattern('_BoundPattern1865_')]), da.pat.TuplePattern([da.pat.ConstantPattern('safe'), da.pat.ConstantPattern(True)])])
PatternExpr_2102 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.BoundPattern('_BoundPattern2108_')]), da.pat.TuplePattern([da.pat.ConstantPattern('learned')])])
PatternExpr_2150 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.BoundPattern('_BoundPattern2156_')]), da.pat.TuplePattern([da.pat.ConstantPattern('Notsafe'), da.pat.ConstantPattern(True)])])
PatternExpr_2182 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.BoundPattern('_BoundPattern2188_')]), da.pat.TuplePattern([da.pat.ConstantPattern('safe'), da.pat.ConstantPattern(False)])])
PatternExpr_2212 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.BoundPattern('_BoundPattern2218_')]), da.pat.TuplePattern([da.pat.ConstantPattern('safe'), da.pat.ConstantPattern(True)])])
PatternExpr_2453 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.BoundPattern('_BoundPattern2459_')]), da.pat.TuplePattern([da.pat.ConstantPattern('learned')])])
PatternExpr_2501 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.BoundPattern('_BoundPattern2507_')]), da.pat.TuplePattern([da.pat.ConstantPattern('Notsafe'), da.pat.ConstantPattern(True)])])
PatternExpr_2533 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.BoundPattern('_BoundPattern2539_')]), da.pat.TuplePattern([da.pat.ConstantPattern('safe'), da.pat.ConstantPattern(False)])])
PatternExpr_2563 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.BoundPattern('_BoundPattern2569_')]), da.pat.TuplePattern([da.pat.ConstantPattern('safe'), da.pat.ConstantPattern(True)])])
_config_object = {}
import sys
from random import randint
import time
from statisticsCalculater import StatisticsCalculator
import warnings
import random

def fxn():
    warnings.warn('deprecated', DeprecationWarning)
with warnings.catch_warnings():
    warnings.simplefilter('ignore')
    fxn()

class Proposer(da.DistProcess):

    def __init__(self, procimpl, forwarder, **props):
        super().__init__(procimpl, forwarder, **props)
        self._ProposerReceivedEvent_1 = []
        self._ProposerReceivedEvent_2 = []
        self._ProposerReceivedEvent_3 = []
        self._ProposerReceivedEvent_4 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_ProposerReceivedEvent_0', PatternExpr_261, sources=[PatternExpr_268], destinations=None, timestamps=None, record_history=None, handlers=[self._Proposer_handler_260]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ProposerReceivedEvent_1', PatternExpr_327, sources=[PatternExpr_334], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ProposerReceivedEvent_2', PatternExpr_369, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ProposerReceivedEvent_3', PatternExpr_400, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ProposerReceivedEvent_4', PatternExpr_436, sources=[PatternExpr_443], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ProposerReceivedEvent_5', PatternExpr_521, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Proposer_handler_520])])

    def setup(self, acceptors, monitor, messageLossRate, messageDelay, waitTimeBeforeStartingNewRound, timeOutProposer, isPreempt, isTimeOut, backOffTime, **rest_2624):
        super().setup(acceptors=acceptors, monitor=monitor, messageLossRate=messageLossRate, messageDelay=messageDelay, waitTimeBeforeStartingNewRound=waitTimeBeforeStartingNewRound, timeOutProposer=timeOutProposer, isPreempt=isPreempt, isTimeOut=isTimeOut, backOffTime=backOffTime, **rest_2624)
        self._state.acceptors = acceptors
        self._state.monitor = monitor
        self._state.messageLossRate = messageLossRate
        self._state.messageDelay = messageDelay
        self._state.waitTimeBeforeStartingNewRound = waitTimeBeforeStartingNewRound
        self._state.timeOutProposer = timeOutProposer
        self._state.isPreempt = isPreempt
        self._state.isTimeOut = isTimeOut
        self._state.backOffTime = backOffTime
        self._state.n = None
        self._state.majority = self._state.acceptors
        self._state.preempt = False

    def run(self):
        while True:
            self.to_consent()
            if ((self._state.isPreempt == True) and self._state.preempt and self._state.backOffTime):
                time.sleep((self._state.waitTimeBeforeStartingNewRound * ((self._state.n[0] % 10) + 1)))
            time.sleep(self._state.waitTimeBeforeStartingNewRound)

    def customSendCommand(self, msg, receivers):
        time.sleep(self._state.messageDelay)
        for receiver in receivers:
            probability = random.random()
            if (probability > self._state.messageLossRate):
                self.send(msg, to=receiver)
            else:
                pass

    def to_consent(self):
        self._state.preempt = False
        self._state.n = ((0, self._id) if (self._state.n == None) else ((self._state.n[0] + 1), self._id))
        self.customSendCommand(('prepare', self._state.n), self._state.majority)
        super()._label('_st_label_321', block=False)
        _st_label_321 = 0
        while (_st_label_321 == 0):
            _st_label_321 += 1
            if ((len({a for (_, (_, _, a), (_ConstantPattern345_, _BoundPattern347_, _)) in self._ProposerReceivedEvent_1 if (_ConstantPattern345_ == 'respond') if (_BoundPattern347_ == self._state.n)}) > (len(self._state.acceptors) / 2)) and ((not self._state.preempt) or (not self._state.isPreempt))):
                v = self.anyof(({v for (_, _, (_ConstantPattern388_, _BoundPattern390_, (n2, v))) in self._ProposerReceivedEvent_2 if (_ConstantPattern388_ == 'respond') if (_BoundPattern390_ == self._state.n) if (n2 == max({n2 for (_, _, (_ConstantPattern417_, _BoundPattern419_, (n2, _))) in self._ProposerReceivedEvent_3 if (_ConstantPattern417_ == 'respond') if (_BoundPattern419_ == self._state.n)}))} or {randint(1, 100)}))
                responded = {a for (_, (_, _, a), (_ConstantPattern454_, _BoundPattern456_, _)) in self._ProposerReceivedEvent_4 if (_ConstantPattern454_ == 'respond') if (_BoundPattern456_ == self._state.n)}
                self.customSendCommand(('accept', self._state.n, v), responded)
                self.debug('### chose', self._state.n, v)
                _st_label_321 += 1
            elif self._timer_expired:
                pass
                _st_label_321 += 1
            elif (self._state.isPreempt and self._state.preempt):
                return
                _st_label_321 += 1
            else:
                super()._label('_st_label_321', block=True, timeout=self._state.timeOutProposer)
                _st_label_321 -= 1
        self._timer_start()

    def anyof(self, s):
        return (next(iter(s)) if s else None)

    def _Proposer_handler_260(self, n2, p):
        if (n2[0] >= self._state.n[0]):
            self._state.preempt = True
            self._state.n = (n2[0], self._id)
    _Proposer_handler_260._labels = None
    _Proposer_handler_260._notlabels = None

    def _Proposer_handler_520(self):
        self.output('Proposer: terminating')
        sys.exit()
    _Proposer_handler_520._labels = None
    _Proposer_handler_520._notlabels = None

class Acceptor(da.DistProcess):

    def __init__(self, procimpl, forwarder, **props):
        super().__init__(procimpl, forwarder, **props)
        self._AcceptorSentEvent_1 = []
        self._AcceptorSentEvent_2 = []
        self._AcceptorSentEvent_3 = []
        self._AcceptorSentEvent_4 = []
        self._AcceptorSentEvent_6 = []
        self._AcceptorReceivedEvent_7 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_AcceptorReceivedEvent_0', PatternExpr_575, sources=[PatternExpr_582], destinations=None, timestamps=None, record_history=None, handlers=[self._Acceptor_handler_574]), da.pat.EventPattern(da.pat.SentEvent, '_AcceptorSentEvent_1', PatternExpr_588, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.SentEvent, '_AcceptorSentEvent_2', PatternExpr_617, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.SentEvent, '_AcceptorSentEvent_3', PatternExpr_643, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.SentEvent, '_AcceptorSentEvent_4', PatternExpr_685, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_AcceptorReceivedEvent_5', PatternExpr_716, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Acceptor_handler_715]), da.pat.EventPattern(da.pat.SentEvent, '_AcceptorSentEvent_6', PatternExpr_729, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_AcceptorReceivedEvent_7', PatternExpr_766, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[])])

    def setup(self, learners, messageLossRate, messageDelay, waitTimeBeforeStartingNewRound, isPreempt, isTimeOut, **rest_2624):
        super().setup(learners=learners, messageLossRate=messageLossRate, messageDelay=messageDelay, waitTimeBeforeStartingNewRound=waitTimeBeforeStartingNewRound, isPreempt=isPreempt, isTimeOut=isTimeOut, **rest_2624)
        self._state.learners = learners
        self._state.messageLossRate = messageLossRate
        self._state.messageDelay = messageDelay
        self._state.waitTimeBeforeStartingNewRound = waitTimeBeforeStartingNewRound
        self._state.isPreempt = isPreempt
        self._state.isTimeOut = isTimeOut
        self._state.totalMessagesLost = 0
        self._state.totalSentTriedMessages = 0

    def run(self):
        super()._label('_st_label_763', block=False)
        _st_label_763 = 0
        while (_st_label_763 == 0):
            _st_label_763 += 1
            if PatternExpr_771.match_iter(self._AcceptorReceivedEvent_7, SELF_ID=self._id):
                _st_label_763 += 1
            else:
                super()._label('_st_label_763', block=True)
                _st_label_763 -= 1
        self.output('Acceptor: terminating')

    def anyof(self, s):
        "return any element of set s if s is not empty or 'None' otherwise"
        return (next(iter(s)) if s else None)

    def customBroadcastSendCommand(self, msg, receivers):
        time.sleep(self._state.messageDelay)
        for receiver in receivers:
            probability = random.random()
            if (probability > self._state.messageLossRate):
                self.send(msg, to=receiver)
            else:
                pass

    def customSendCommand(self, msg, receiver):
        time.sleep(self._state.messageDelay)
        probability = random.random()
        if (probability > self._state.messageLossRate):
            self.send(msg, to=receiver)
        else:
            pass

    def _Acceptor_handler_574(self, n, p):
        n2 = None

        def UniversalOpExpr_586():
            nonlocal n2
            for (_, _, (_ConstantPattern604_, n2, _)) in self._AcceptorSentEvent_1:
                if (_ConstantPattern604_ == 'respond'):
                    if (not (n > n2)):
                        return False
            return True
        if UniversalOpExpr_586():
            maxprop = self.anyof({(n, v) for (_, _, (_ConstantPattern633_, n, v)) in self._AcceptorSentEvent_2 if (_ConstantPattern633_ == 'accepted') if (n == max({n for (_, _, (_ConstantPattern658_, n, _)) in self._AcceptorSentEvent_3 if (_ConstantPattern658_ == 'accepted')}))})
            self.customSendCommand(('respond', n, maxprop), p)
        elif (self._state.isPreempt == True):
            n2 = max({n2 for (_, _, (_ConstantPattern700_, n2, _)) in self._AcceptorSentEvent_4 if (_ConstantPattern700_ == 'respond')})
            self.customSendCommand(('PreemtPropose', n2), p)
    _Acceptor_handler_574._labels = None
    _Acceptor_handler_574._notlabels = None

    def _Acceptor_handler_715(self, n, v):
        n2 = None

        def ExistentialOpExpr_727():
            nonlocal n2
            for (_, _, (_ConstantPattern745_, n2, _)) in self._AcceptorSentEvent_6:
                if (_ConstantPattern745_ == 'respond'):
                    if (n2 > n):
                        return True
            return False
        if (not ExistentialOpExpr_727()):
            self.customBroadcastSendCommand(('accepted', n, v), self._state.learners)
    _Acceptor_handler_715._labels = None
    _Acceptor_handler_715._notlabels = None

class Learner(da.DistProcess):

    def __init__(self, procimpl, forwarder, **props):
        super().__init__(procimpl, forwarder, **props)
        self._LearnerReceivedEvent_0 = []
        self._LearnerReceivedEvent_1 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_LearnerReceivedEvent_0', PatternExpr_875, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_LearnerReceivedEvent_1', PatternExpr_901, sources=[PatternExpr_908], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_LearnerReceivedEvent_2', PatternExpr_997, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Learner_handler_996])])

    def setup(self, acceptors, monitor, timeOutLearner, isTimeOut, **rest_2624):
        super().setup(acceptors=acceptors, monitor=monitor, timeOutLearner=timeOutLearner, isTimeOut=isTimeOut, **rest_2624)
        self._state.acceptors = acceptors
        self._state.monitor = monitor
        self._state.timeOutLearner = timeOutLearner
        self._state.isTimeOut = isTimeOut
        self._state.valueAchieved = False

    def run(self):
        while (not self._state.valueAchieved):
            self.learn()
        self.output('Learner: terminating')
        self.send(('learned',), to=self.nodeof(self._id))
        sys.exit()

    def learn(self):
        super()._label('_st_label_872', block=False)
        n = v = a = None

        def ExistentialOpExpr_873():
            nonlocal n, v, a
            for (_, _, (_ConstantPattern892_, n, v)) in self._LearnerReceivedEvent_0:
                if (_ConstantPattern892_ == 'accepted'):
                    if (len({a for (_, (_, _, a), (_ConstantPattern919_, _BoundPattern921_, _BoundPattern922_)) in self._LearnerReceivedEvent_1 if (_ConstantPattern919_ == 'accepted') if (_BoundPattern921_ == n) if (_BoundPattern922_ == v)}) > (len(self._state.acceptors) / 2)):
                        return True
            return False
        _st_label_872 = 0
        while (_st_label_872 == 0):
            _st_label_872 += 1
            if ExistentialOpExpr_873():
                self.output('learned', n, v)
                self.send(('valueLearnt', n, v), to=self._state.monitor)
                self._state.valueAchieved = True
                _st_label_872 += 1
            elif self._timer_expired:
                if self._state.isTimeOut:
                    self.output('Learner: terminating')
                    self.send(('learned',), to=self.nodeof(self._id))
                    self.output('failed learning anything')
                    sys.exit()
                else:
                    pass
                _st_label_872 += 1
            else:
                super()._label('_st_label_872', block=True, timeout=self._state.timeOutLearner)
                _st_label_872 -= 1
        self._timer_start()

    def _Learner_handler_996(self):
        self.output('Learner: terminating')
        sys.exit()
    _Learner_handler_996._labels = None
    _Learner_handler_996._notlabels = None

class Monitor(da.DistProcess):

    def __init__(self, procimpl, forwarder, **props):
        super().__init__(procimpl, forwarder, **props)
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_MonitorReceivedEvent_0', PatternExpr_1038, sources=[PatternExpr_1047], destinations=None, timestamps=None, record_history=None, handlers=[self._Monitor_handler_1037]), da.pat.EventPattern(da.pat.ReceivedEvent, '_MonitorReceivedEvent_1', PatternExpr_1092, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Monitor_handler_1091])])

    def setup(self, learners, **rest_2624):
        super().setup(learners=learners, **rest_2624)
        self._state.learners = learners
        self._state.numberOfLearntLearners = 0
        self._state.ValueLearnt = (- 1)
        self._state.isSafe = True

    def run(self):
        super()._label('_st_label_1139', block=False)
        _st_label_1139 = 0
        while (_st_label_1139 == 0):
            _st_label_1139 += 1
            if False:
                _st_label_1139 += 1
            else:
                super()._label('_st_label_1139', block=True)
                _st_label_1139 -= 1

    def _Monitor_handler_1037(self, n, v, p):
        self.output(('Monitor: Value Learnt - ' + str((n, v))))
        self._state.numberOfLearntLearners += 1
        if (self._state.numberOfLearntLearners == 1):
            self._state.ValueLearnt = v
        elif (not (self._state.ValueLearnt == v)):
            self._state.isSafe = False
            self.output('Monitor: Faulty State reached - Multiple Values Learnt')
    _Monitor_handler_1037._labels = None
    _Monitor_handler_1037._notlabels = None

    def _Monitor_handler_1091(self):
        if (not (self._state.numberOfLearntLearners == len(self._state.learners))):
            self.output('Algorithm aborted purposely. No consesus reached. Liveliness Failed.')
        consensusAchieved = (self._state.numberOfLearntLearners == len(self._state.learners))
        if (self._state.isSafe == False):
            self.send(('Notsafe', consensusAchieved), to=self.nodeof(self._id))
        else:
            self.send(('safe', consensusAchieved), to=self.nodeof(self._id))
        sys.exit()
    _Monitor_handler_1091._labels = None
    _Monitor_handler_1091._notlabels = None

class Node_(da.NodeProcess):

    def __init__(self, procimpl, forwarder, **props):
        super().__init__(procimpl, forwarder, **props)
        self._Node_ReceivedEvent_0 = []
        self._Node_ReceivedEvent_1 = []
        self._Node_ReceivedEvent_2 = []
        self._Node_ReceivedEvent_3 = []
        self._Node_ReceivedEvent_4 = []
        self._Node_ReceivedEvent_5 = []
        self._Node_ReceivedEvent_6 = []
        self._Node_ReceivedEvent_7 = []
        self._Node_ReceivedEvent_8 = []
        self._Node_ReceivedEvent_9 = []
        self._Node_ReceivedEvent_10 = []
        self._Node_ReceivedEvent_11 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_Node_ReceivedEvent_0', PatternExpr_1741, sources=[PatternExpr_1746], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_Node_ReceivedEvent_1', PatternExpr_1788, sources=[PatternExpr_1795], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_Node_ReceivedEvent_2', PatternExpr_1820, sources=[PatternExpr_1827], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_Node_ReceivedEvent_3', PatternExpr_1850, sources=[PatternExpr_1857], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_Node_ReceivedEvent_4', PatternExpr_2095, sources=[PatternExpr_2100], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_Node_ReceivedEvent_5', PatternExpr_2141, sources=[PatternExpr_2148], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_Node_ReceivedEvent_6', PatternExpr_2173, sources=[PatternExpr_2180], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_Node_ReceivedEvent_7', PatternExpr_2203, sources=[PatternExpr_2210], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_Node_ReceivedEvent_8', PatternExpr_2446, sources=[PatternExpr_2451], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_Node_ReceivedEvent_9', PatternExpr_2492, sources=[PatternExpr_2499], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_Node_ReceivedEvent_10', PatternExpr_2524, sources=[PatternExpr_2531], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_Node_ReceivedEvent_11', PatternExpr_2554, sources=[PatternExpr_2561], destinations=None, timestamps=None, record_history=True, handlers=[])])

    def run(self):
        messageLossRate = 0.0
        messageDelay = 0.0
        waitTimeBeforeStartingNewRound = 0
        timeOutProposer = 10.0
        timeOutLearner = 20.0
        isPreempt = False
        isTimeOut = False
        maxTimeForEachRun = 50
        nacceptors = 3
        nproposers = 5
        nlearners = 3
        nproposers = (int(sys.argv[1]) if (len(sys.argv) > 1) else 5)
        nacceptors = (int(sys.argv[2]) if (len(sys.argv) > 2) else 3)
        nlearners = (int(sys.argv[3]) if (len(sys.argv) > 3) else 3)
        numberOfRepetitions = (int(sys.argv[4]) if (len(sys.argv) > 4) else 5)
        messageLossRateInput = (float(sys.argv[5]) if (len(sys.argv) > 5) else 0.1)
        messageDelayInput = (float(sys.argv[6]) if (len(sys.argv) > 6) else 0.2)
        waitTimeBeforeStartingNewRoundInput = (float(sys.argv[7]) if (len(sys.argv) > 7) else 0.5)
        timeOutProposer = (float(sys.argv[8]) if (len(sys.argv) > 8) else 1)
        timeOutLearner = (float(sys.argv[9]) if (len(sys.argv) > 9) else 1)
        checkPreempt = (str(sys.argv[10]) if (len(sys.argv) > 10) else 'True')
        checkTimeOut = (str(sys.argv[11]) if (len(sys.argv) > 11) else 'False')
        outputFileName = (str(sys.argv[12]) if (len(sys.argv) > 12) else 'DirectoryFile')
        maxTimeForEachRun = (int(sys.argv[13]) if (len(sys.argv) > 13) else 50)
        backOffTime = (boolean(sys.argv[14]) if (len(sys.argv) > 14) else False)
        print(('Proposer Number :' + str(nproposers)))
        print(('Acceptor Number :' + str(nacceptors)))
        print(('Learners Number :' + str(nlearners)))
        print(('numberOfRepetitions Number :' + str(numberOfRepetitions)))
        print(('messageDelayInput :' + str(messageDelayInput)))
        print(('waitTimeBeforeStartingNewRoundInput :' + str(waitTimeBeforeStartingNewRoundInput)))
        print(('timeOutProposer :' + str(timeOutProposer)))
        print(('timeOutLearner :' + str(timeOutLearner)))
        print(('checkPreempt :' + str(checkPreempt)))
        print(('checkTimeOut :' + str(checkTimeOut)))
        print(('outputFileName :' + str(outputFileName)))
        print(('maxTimeForEachRun :' + str(maxTimeForEachRun)))
        if (checkPreempt == 'False'):
            isPreempt = False
        else:
            isPreempt = True
        if (checkTimeOut == 'False'):
            isTimeOut = False
        else:
            isTimeOut = True
        if (isTimeOut == False):
            timeOutProposer = 100
            timeOutLearner = 100
        assert ((not isTimeOut) or ((messageDelayInput < timeOutLearner) and (messageDelayInput < timeOutProposer)))
        assert ((messageLossRateInput >= 0) and (messageLossRateInput <= 1))
        messageDelay = messageDelayInput
        waitTimeBeforeStartingNewRound = waitTimeBeforeStartingNewRoundInput
        messageLossRateParameters = [(messageLossRateInput / 5), ((messageLossRateInput * 2) / 5), ((messageLossRateInput * 3) / 5), ((messageLossRateInput * 4) / 5), messageLossRateInput]
        statisticsCalculator = StatisticsCalculator(timeOutLearner, timeOutProposer, outputFileName)
        statisticsCalculator.addTableHeader('MessageLoss', 'MessageDelay', 'WaitTime')
        for messageLossRateParamter in messageLossRateParameters:
            messageLossRate = messageLossRateParamter
            print(('***************************************** messageLossRate: ' + str(messageLossRate)))
            consensusSafety = True
            consensusLiveness = 0
            (cpuTime, elapsedTime) = (list(), list())
            for i in range(numberOfRepetitions):
                (elpstart, cpustart) = (time.time(), time.process_time())
                print(('***************************************** Run No: ' + str((i + 1))))
                acceptors = self.new(Acceptor, num=nacceptors)
                monitor = self.new(Monitor, num=1)
                proposers = self.new(Proposer, (acceptors, monitor, messageLossRate, messageDelay, waitTimeBeforeStartingNewRound, timeOutProposer, isPreempt, isTimeOut, backOffTime), num=nproposers)
                learners = self.new(Learner, (acceptors, monitor, timeOutLearner, isTimeOut), num=nlearners)
                for p in acceptors:
                    self._setup(p, (learners, messageLossRate, messageDelay, waitTimeBeforeStartingNewRound, isPreempt, isTimeOut))
                self._setup(monitor, (learners,))
                self._start((((acceptors | proposers) | learners) | monitor))
                super()._label('_st_label_1732', block=False)
                l = None

                def UniversalOpExpr_1733():
                    nonlocal l
                    for l in learners:
                        if (not PatternExpr_1748.match_iter(self._Node_ReceivedEvent_0, _BoundPattern1754_=l)):
                            return False
                    return True
                _st_label_1732 = 0
                while (_st_label_1732 == 0):
                    _st_label_1732 += 1
                    if UniversalOpExpr_1733():
                        pass
                        _st_label_1732 += 1
                    elif self._timer_expired:
                        self.output('Forcefully Terminated Algorithm')
                        self.send(('done',), to=learners)
                        _st_label_1732 += 1
                    else:
                        super()._label('_st_label_1732', block=True, timeout=maxTimeForEachRun)
                        _st_label_1732 -= 1
                else:
                    if (_st_label_1732 != 2):
                        continue
                self._timer_start()
                if (_st_label_1732 != 2):
                    break
                self.send(('done',), to=((acceptors | proposers) | monitor))
                super()._label('_st_label_1779', block=False)
                m = None

                def UniversalOpExpr_1780():
                    nonlocal m
                    for m in monitor:
                        if (not PatternExpr_1797.match_iter(self._Node_ReceivedEvent_1, _BoundPattern1803_=m)):
                            return False
                    return True
                m = None

                def UniversalOpExpr_1813():
                    nonlocal m
                    for m in monitor:
                        if (not PatternExpr_1829.match_iter(self._Node_ReceivedEvent_2, _BoundPattern1835_=m)):
                            return False
                    return True
                m = None

                def UniversalOpExpr_1843():
                    nonlocal m
                    for m in monitor:
                        if (not PatternExpr_1859.match_iter(self._Node_ReceivedEvent_3, _BoundPattern1865_=m)):
                            return False
                    return True
                _st_label_1779 = 0
                while (_st_label_1779 == 0):
                    _st_label_1779 += 1
                    if UniversalOpExpr_1780():
                        consensusSafety = False
                        _st_label_1779 += 1
                    elif UniversalOpExpr_1813():
                        pass
                        _st_label_1779 += 1
                    elif UniversalOpExpr_1843():
                        consensusLiveness += 1
                        _st_label_1779 += 1
                    else:
                        super()._label('_st_label_1779', block=True)
                        _st_label_1779 -= 1
                else:
                    if (_st_label_1779 != 2):
                        continue
                if (_st_label_1779 != 2):
                    break
                print('***************************************** Pass over')
                (elpstop, cpustop) = (time.time(), time.process_time())
                cpuTime.append((cpustop - cpustart))
                elapsedTime.append((elpstop - elpstart))
            statisticsCalculator.addEntry(messageLossRateParamter, cpuTime, elapsedTime, isTimeOut, isPreempt, messageDelay, waitTimeBeforeStartingNewRound, consensusSafety, consensusLiveness)
        statisticsCalculator.report()
        messageLossRate = messageLossRateInput
        waitTimeBeforeStartingNewRound = waitTimeBeforeStartingNewRoundInput
        messageDelayParameters = [(messageDelayInput / 5), ((messageDelayInput * 2) / 5), ((messageDelayInput * 3) / 5), ((messageDelayInput * 4) / 5), messageDelayInput]
        statisticsCalculator = StatisticsCalculator(timeOutLearner, timeOutProposer, outputFileName)
        statisticsCalculator.addTableHeader('MessageDelay', 'MessageLoss', 'WaitTime')
        for messageDelayParameter in messageDelayParameters:
            messageDelay = messageDelayParameter
            consensusSafety = True
            consensusLiveness = 0
            (cpuTime, elapsedTime) = (list(), list())
            print(('***************************************** messageDelay: ' + str(messageDelayParameter)))
            for i in range(numberOfRepetitions):
                (elpstart, cpustart) = (time.time(), time.process_time())
                print(('***************************************** Run No: ' + str((i + 1))))
                acceptors = self.new(Acceptor, num=nacceptors)
                monitor = self.new(Monitor, num=1)
                proposers = self.new(Proposer, (acceptors, monitor, messageLossRate, messageDelay, waitTimeBeforeStartingNewRound, timeOutProposer, isPreempt, isTimeOut, backOffTime), num=nproposers)
                learners = self.new(Learner, (acceptors, monitor, timeOutLearner, isTimeOut), num=nlearners)
                for p in acceptors:
                    self._setup(p, (learners, messageLossRate, messageDelay, waitTimeBeforeStartingNewRound, isPreempt, isTimeOut))
                self._setup(monitor, (learners,))
                self._start((((acceptors | proposers) | learners) | monitor))
                super()._label('_st_label_2087', block=False)
                l = None

                def UniversalOpExpr_2088():
                    nonlocal l
                    for l in learners:
                        if (not PatternExpr_2102.match_iter(self._Node_ReceivedEvent_4, _BoundPattern2108_=l)):
                            return False
                    return True
                _st_label_2087 = 0
                while (_st_label_2087 == 0):
                    _st_label_2087 += 1
                    if UniversalOpExpr_2088():
                        pass
                        _st_label_2087 += 1
                    elif self._timer_expired:
                        self.output('Forcefully Terminated Algorithm')
                        self.send(('done',), to=learners)
                        _st_label_2087 += 1
                    else:
                        super()._label('_st_label_2087', block=True, timeout=maxTimeForEachRun)
                        _st_label_2087 -= 1
                else:
                    if (_st_label_2087 != 2):
                        continue
                self._timer_start()
                if (_st_label_2087 != 2):
                    break
                self.send(('done',), to=((acceptors | proposers) | monitor))
                super()._label('_st_label_2133', block=False)
                m = None

                def UniversalOpExpr_2134():
                    nonlocal m
                    for m in monitor:
                        if (not PatternExpr_2150.match_iter(self._Node_ReceivedEvent_5, _BoundPattern2156_=m)):
                            return False
                    return True
                m = None

                def UniversalOpExpr_2166():
                    nonlocal m
                    for m in monitor:
                        if (not PatternExpr_2182.match_iter(self._Node_ReceivedEvent_6, _BoundPattern2188_=m)):
                            return False
                    return True
                m = None

                def UniversalOpExpr_2196():
                    nonlocal m
                    for m in monitor:
                        if (not PatternExpr_2212.match_iter(self._Node_ReceivedEvent_7, _BoundPattern2218_=m)):
                            return False
                    return True
                _st_label_2133 = 0
                while (_st_label_2133 == 0):
                    _st_label_2133 += 1
                    if UniversalOpExpr_2134():
                        consensusSafety = False
                        _st_label_2133 += 1
                    elif UniversalOpExpr_2166():
                        pass
                        _st_label_2133 += 1
                    elif UniversalOpExpr_2196():
                        consensusLiveness += 1
                        _st_label_2133 += 1
                    else:
                        super()._label('_st_label_2133', block=True)
                        _st_label_2133 -= 1
                else:
                    if (_st_label_2133 != 2):
                        continue
                if (_st_label_2133 != 2):
                    break
                print('***************************************** Pass over')
                (elpstop, cpustop) = (time.time(), time.process_time())
                cpuTime.append((cpustop - cpustart))
                elapsedTime.append((elpstop - elpstart))
            statisticsCalculator.addEntry(messageDelay, cpuTime, elapsedTime, isTimeOut, isPreempt, messageLossRate, waitTimeBeforeStartingNewRound, consensusSafety, consensusLiveness)
        statisticsCalculator.report()
        statisticsCalculator = StatisticsCalculator(timeOutLearner, timeOutProposer, outputFileName)
        statisticsCalculator.addTableHeader('WaitTime', 'MessageDelay', 'MessageLoss')
        messageLossRate = messageLossRateInput
        messageDelay = messageDelayInput
        waitTimeBeforeStartingNewRoundParameters = [(waitTimeBeforeStartingNewRoundInput / 5), ((waitTimeBeforeStartingNewRoundInput * 2) / 5), ((waitTimeBeforeStartingNewRoundInput * 3) / 5), ((waitTimeBeforeStartingNewRoundInput * 4) / 5), waitTimeBeforeStartingNewRoundInput]
        for waitTimeBeforeStartingNewRoundParameter in waitTimeBeforeStartingNewRoundParameters:
            waitTimeBeforeStartingNewRound = waitTimeBeforeStartingNewRoundParameter
            consensusSafety = True
            consensusLiveness = 0
            (cpuTime, elapsedTime) = (list(), list())
            print(('***************************************** waitTimeBeforeStartingNewRound: ' + str(waitTimeBeforeStartingNewRoundParameter)))
            for i in range(numberOfRepetitions):
                (elpstart, cpustart) = (time.time(), time.process_time())
                print(('***************************************** Run No: ' + str((i + 1))))
                acceptors = self.new(Acceptor, num=nacceptors)
                monitor = self.new(Monitor, num=1)
                proposers = self.new(Proposer, (acceptors, monitor, messageLossRate, messageDelay, waitTimeBeforeStartingNewRound, timeOutProposer, isPreempt, isTimeOut, backOffTime), num=nproposers)
                learners = self.new(Learner, (acceptors, monitor, timeOutLearner, isTimeOut), num=nlearners)
                for p in acceptors:
                    self._setup(p, (learners, messageLossRate, messageDelay, waitTimeBeforeStartingNewRound, isPreempt, isTimeOut))
                self._setup(monitor, (learners,))
                self._start((((acceptors | proposers) | learners) | monitor))
                super()._label('_st_label_2438', block=False)
                l = None

                def UniversalOpExpr_2439():
                    nonlocal l
                    for l in learners:
                        if (not PatternExpr_2453.match_iter(self._Node_ReceivedEvent_8, _BoundPattern2459_=l)):
                            return False
                    return True
                _st_label_2438 = 0
                while (_st_label_2438 == 0):
                    _st_label_2438 += 1
                    if UniversalOpExpr_2439():
                        pass
                        _st_label_2438 += 1
                    elif self._timer_expired:
                        self.output('Forcefully Terminated Algorithm')
                        self.send(('done',), to=learners)
                        _st_label_2438 += 1
                    else:
                        super()._label('_st_label_2438', block=True, timeout=maxTimeForEachRun)
                        _st_label_2438 -= 1
                else:
                    if (_st_label_2438 != 2):
                        continue
                self._timer_start()
                if (_st_label_2438 != 2):
                    break
                self.send(('done',), to=((acceptors | proposers) | monitor))
                super()._label('_st_label_2484', block=False)
                m = None

                def UniversalOpExpr_2485():
                    nonlocal m
                    for m in monitor:
                        if (not PatternExpr_2501.match_iter(self._Node_ReceivedEvent_9, _BoundPattern2507_=m)):
                            return False
                    return True
                m = None

                def UniversalOpExpr_2517():
                    nonlocal m
                    for m in monitor:
                        if (not PatternExpr_2533.match_iter(self._Node_ReceivedEvent_10, _BoundPattern2539_=m)):
                            return False
                    return True
                m = None

                def UniversalOpExpr_2547():
                    nonlocal m
                    for m in monitor:
                        if (not PatternExpr_2563.match_iter(self._Node_ReceivedEvent_11, _BoundPattern2569_=m)):
                            return False
                    return True
                _st_label_2484 = 0
                while (_st_label_2484 == 0):
                    _st_label_2484 += 1
                    if UniversalOpExpr_2485():
                        consensusSafety = False
                        _st_label_2484 += 1
                    elif UniversalOpExpr_2517():
                        pass
                        _st_label_2484 += 1
                    elif UniversalOpExpr_2547():
                        consensusLiveness += 1
                        _st_label_2484 += 1
                    else:
                        super()._label('_st_label_2484', block=True)
                        _st_label_2484 -= 1
                else:
                    if (_st_label_2484 != 2):
                        continue
                if (_st_label_2484 != 2):
                    break
                print('***************************************** Pass over')
                (elpstop, cpustop) = (time.time(), time.process_time())
                cpuTime.append((cpustop - cpustart))
                elapsedTime.append((elpstop - elpstart))
            statisticsCalculator.addEntry(waitTimeBeforeStartingNewRound, cpuTime, elapsedTime, isTimeOut, isPreempt, messageDelay, messageLossRate, consensusSafety, consensusLiveness)
        statisticsCalculator.report()
