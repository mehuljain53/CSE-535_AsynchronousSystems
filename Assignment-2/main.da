import sys
import time
config(channel is fifo, clock is lamport)
import json
from itertools import chain


# Resource usage data tracking. Reports several measurements
# of time between start and end, and memory usage at end.

class WinResourceUsageData:
    
    """Tracks process time only."""
    
    def start(self):
        self.start_cputime = time.process_time()
    
    def end(self):
        self.end_cputime = time.process_time()
        
        self.results = {
            'Total_process_time': self.end_cputime - self.start_cputime,
        }
    
    @classmethod
    def aggregate(cls, rudata_points):
        return {
            'Total_process_time': sum(p.results['Total_process_time']
                                      for p in rudata_points),
            'Total_processes': len(rudata_points),
        }

class PosixResourceUsageData:
    
    """Tracks utime, stime, and maxrss."""
    
    def start(self):
        self.start_data = resource.getrusage(resource.RUSAGE_SELF)
    
    def end(self):
        self.end_data = resource.getrusage(resource.RUSAGE_SELF)
        
        def diff(attr):
            return (getattr(self.end_data, attr) -
                    getattr(self.start_data, attr))
        
        self.results = {
            'Total_user_time': diff('ru_utime'),
            'Total_system_time': diff('ru_stime'),
            'Total_process_time': diff('ru_utime') + diff('ru_stime'),
            'Total_memory': self.end_data.ru_maxrss,
        }
    
    @classmethod
    def aggregate(cls, rudata_points):
        def sumof(attr):
            return sum(p.results[attr] for p in rudata_points)
        aggr_results = {k: sumof(k) for k in [
            'Total_user_time', 'Total_system_time',
            'Total_process_time', 'Total_memory']}
        aggr_results['Total_processes'] = len(rudata_points)
        return aggr_results

if sys.platform == "win32":
    ResourceUsageData = WinResourceUsageData
else:
    import resource
    ResourceUsageData = PosixResourceUsageData



class Monitor(process):  
    def setup(exc:bool,nprocs:int):
        self.count =0
        self.exc=True
        self.rudataList = list()
        self.recievedFinishExecution = 0
        self.elapsedTime =0
        self.isDeadlock = False
        self.totalCriticalSectionExecuted=0
    
    def run():
        #print("Monitor on")
        startTime = time.time()
        while exc:
            -- chk
            pass
        endTime = time.time()
        self.elapsedTime = endTime - startTime
        jsonResult = ResourceUsageData.aggregate(rudataList)
        jsonResult['elapsedTime'] = self.elapsedTime
        jsonResult['IsDeadlock'] = isDeadlock
        jsonResult['TotalCriticalSectionExecuted'] = totalCriticalSectionExecuted
        print(jsonResult)
        #print("Total Time: %f" %(self.elapsedTime))
        send(('done', self), to= parent())
        #print("Monitor off..")

    def receive(msg= ('execCS',_, _)):
        #print("execCS")
        count=count+1
        self.totalCriticalSectionExecuted+=1
        if count >= 2:
            print("System Safety Compromised ")

    def receive(msg= ('finishCS',_, _)):
        count=count-1
        if count<0:
            print("System Behaving abruptly")


    def receive(msg= ('finishExecution',rudata), from_=source):
        recievedFinishExecution+=1;
        rudataList.append(rudata)
        #print("finishExecution message Received %d"%(recievedFinishExecution))
        if(recievedFinishExecution==self.nprocs):
            self.exc=False

    def receive(msg= ('Deadlock')):
        isDeadlock = True


class P(process):
    def setup(s:set, nrequests:int,id:int,monitor:Monitor):  # s is set of all other processes
        self.q = set()
        self.rudata = ResourceUsageData()

    def request():
        -- request
        c = logical_clock()
        #print("Requesting %d" % (id))
        send(('request', c, self), to= s)
        q.add(('request', c, self))


    def executeCriticalSection():
        -- Execute
        min = logical_clock()
        p=self
        for (x, c, p) in q:
            if p == self and c<min:
                min = c

        c = min
        if(await(each(('request', c2, p) in q,
                   has= (c2, p)==(c, self) or (c, self) < (c2, p)) and
              each(p in s, has= some(received(('ack', c2, _p)), has= c2 > c)))):
            -- critical_section
            send(('execCS', logical_clock(), self), to= monitor)
            task()
            send(('finishCS', logical_clock(), self), to= monitor)
            release(c)
        elif(timeout(2)):
            #output('Deadlock Found')
            send(('Deadlock'),to=monitor)

    def release(c:int):
        #print("Removing %d %d" % (id,c))
        -- release
        q.remove(('request', c, self))
        send(('release', logical_clock(), self), to= s)


    def receive(msg= ('request', c2, p)):
        q.add(('request', c2, p))
        send(('ack', logical_clock(), self), to= p)

    def receive(msg= ('release',_, p)):
        for x in q:
            if p == x[2]:
                #print("Removing %d %d" % (id,x[1]))
                q.remove(x)
                break

    def task():
        #print("In CriticalSection %d" % (id))
        time.sleep(0.1)
        #print("Out CriticalSection %d" % (id))

    def run():
        self.rudata.start()
        for i in range(nrequests):
            request()

        for i in range(nrequests):    
            executeCriticalSection()
            

        send(('done', self), to= parent())
        await(received(('done',), from_=parent()))
        self.rudata.end()
        rudataResult = getattr(self.rudata, 'results')
        send(('finishExecution',rudata), to=monitor)
        #output('terminating')

def main():
    nprocs = int(sys.argv[1]) if len(sys.argv) > 1 else 10
    nrequests = int(sys.argv[2]) if len(sys.argv) > 2 else 1
    n = int(sys.argv[3]) if len(sys.argv) > 3 else 1
    d = int(sys.argv[4]) if len(sys.argv) > 4 else 1
    a = int(sys.argv[5]) if len(sys.argv) > 5 else 1



    ######## My version of Lamport running n times with nprocs process and nrequests request
    print("***************************Running Correctness for Lamport Clock as mentioned in Assignementk***************************")
    for i in range(n):
        print("Result for Iteration %d" %(i))
        ps = new(P, num=nprocs)
        monitor = new(Monitor,num=1)
        setup(monitor,(True,nprocs))
        count=0
        for p in ps: 
            setup(p, (ps-{p}, nrequests,count,monitor))
            count+=1
        start(monitor)
        start(ps)
        await(each(p in ps, has=received(('done', p))))
        send(('done',), to=ps)
        await(each(p in monitor, has=received(('done', p))))


    

# This is an executable specification of the algorithm described in
# Lamport, L. (1978). "Time, clocks, and the ordering of events in a
# distributed system".  Communications of the ACM, 21(7):558-565.

# This code includes setup and termination for serving a given number of
# requests per process.


